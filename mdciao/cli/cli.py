##############################################################################
#    This file is part of mdciao.
#    
#    Copyright 2020 Charité Universitätsmedizin Berlin and the Authors
#
#    Authors: Guillermo Pérez-Hernandez
#    Contributors:
#
#    mdciao is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Lesser General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    mdciao is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Lesser General Public License for more details.
#
#    You should have received a copy of the GNU Lesser General Public License
#    along with mdciao.  If not, see <https://www.gnu.org/licenses/>.
##############################################################################


my_frag_colors=[
         'magenta',
         'yellow',
         'lime',
         'maroon',
         'navy',
         'olive',
         'orange',
         'purple',
         'teal',
]

from os import path as _path, mkdir as _mkdir
import numpy as _np
import mdtraj as _md
from matplotlib import pyplot as _plt, rcParams as _rcParams, colors as _mplcolors

from pandas import DataFrame as _DF
from pandas import ExcelWriter as _ExcelWriter

from inspect import signature as _signature
from fnmatch import filter as _filter
from textwrap import wrap as _twrap
from itertools import product as _iterpd

import mdciao.contacts as _mdcctcs
import mdciao.fragments as _mdcfrg
import mdciao.nomenclature as _mdcnomenc

import mdciao.sites as _mdcsites
import mdciao.plots as _mdcplots

import mdciao.utils as _mdcu

from mdciao.flare import _utils as _mdcfu


def _offer_to_create_dir(output_dir):
    r"""
    Offer to create a directory if it does not
    exist. Does nothing if it already exists

    Parameters
    ----------
    output_dir : str

    Returns
    -------

    """
    if not _path.isdir(output_dir):
        answer = input("\nThe directory '%s' does not exist. Create it on the fly [y/n]?\nDefault [y]: " % output_dir)
        if len(answer) == 0 or answer.lower().startswith("y"):
            _mkdir(output_dir)
        else:
            print("Stopping. Please check your variable 'output_dir' and try again")
            return

def _parse_consensus_option(option, consensus_type,
                            top, fragments,
                            return_Labeler=False,
                            accept_guess=False,
                            **LabelerConsensus_kwargs):
    r"""

    Frankenstein method to hide complexity away fom the command-line tools
    while making them usable at the API-level

    Internally, it instantiates a :obj:`LabelerConsensus` object to use
    its :obj:`LabelerConsensus.top2map` method
    
    A guess is performed on-the-fly using :obj:`guess_by_nomenclature`
    to better align :obj:`top` to the :obj:`LabelerConsensus`.

    Parameters
    ----------
    option : the option that was passed as argument.
        There's three usecases:
         * None, str(None)
           Nothing happens, an residx2conlab map
           full of Nones is returned
         * str
          The needed identifier to instantiate an
          :obj:`LabelerBW` or an :obj:`LabelerCGN` object.
          Examples would be a :obj:`uniprot_name` or a :obj:`ref_PDB`,
          respectively
         * :obj:`LabelerConsensus`
          An already instantiated :obj:`LabelerBW` or :obj:`LabelerCGN`
          The method then does nothing. Usecase are repeated
          calls to any of the methods in :obj:`command_line_tools`
          without each call instantiating its own :obj:`LabelerConsensus`
    consensus_type : str
        Either "CGN" or "BW"
    top : :obj:`mdtraj.Topology`
    fragments : iterable of iterables of ints
        How the :obj:`top` is fragmented. Helps
        to identify what part of :obj:`top`
        to align to the consensus sequence and produce
        the residx2conlab map
    return_Labeler : bool, default is False
        Whether to return the object itself
    accept_guess : bool, default is False
        Accept the guess generated by
        :obj:`guess_by_nomenclature` without asking
        questions
    LabelerConsensus_kwargs : opt
        Keyword arguments of for the :obj:`LabelerConsensus`

    Returns
    -------
    map, LC

    """
    if isinstance(option, str) or option is None:
        if str(option).lower() == 'none':
            map_out = [None for __ in range(top.n_residues)]
            LC_out = None
        else:
            LC_out = {"BW": _mdcnomenc.LabelerBW,
                      "CGN":_mdcnomenc.LabelerCGN}[consensus_type](option, **LabelerConsensus_kwargs)

    #todo add a class check here instead of failing later on
    else:
        LC_out = option
        #print("The transformer was provided already")

    if LC_out is not None:
        answer = _mdcnomenc.guess_by_nomenclature(LC_out, top, fragments, consensus_type,
                                        return_str=False,
                                        accept_guess=accept_guess,
                                        #verbose=True
                                        )
        if answer is None:
            print("No fragments belonging to the nomenclature data\n"
                  " could be guessed based on your fragments, this might be a weird case")
            restrict_to_residxs = None
        else:
            restrict_to_residxs = _np.hstack([fragments[ii] for ii in answer])
        map_out = LC_out.top2map(top,
                                 min_hit_rate=0, # We need give-up the re-guessing here,
                                 # because explicitely done it before with an option for
                                 # interactivity
                                 restrict_to_residxs=restrict_to_residxs,
                                 guess_consensus=True,
                             #    verbose=True,
                                 )
    if not return_Labeler:
        return map_out
    else:
        return map_out, LC_out

#TODO test
#TODO document
def _parse_consensus_options_and_return_fragment_defs(option_dict, top,
                                                      fragments_as_residue_idxs,
                                                      accept_guess=False,
                                                      save_nomenclature_files=False,
                                                      verbose=True):
    fragment_defs, consensus_maps, consensus_labelers = {}, [], {}
    for key, option in option_dict.items():
        map_CL, CL = _parse_consensus_option(option, key, top, fragments_as_residue_idxs,
                                           return_Labeler=True,
                                           accept_guess=accept_guess,
                                           write_to_disk=save_nomenclature_files)
        consensus_maps.append(map_CL)
        if CL is not None:
            consensus_labelers[key] = CL
            if verbose:
                print("These are the %s fragments mapped onto your topology:"%key)
                fragment_defs.update(CL.top2defs(top,
                                                 map_conlab=map_CL,
                                                 fragments=fragments_as_residue_idxs,
                                                 return_defs=True,
                                                 verbose=verbose))
            if not accept_guess:
                input("Hit enter to continue!\n")

    return fragment_defs, consensus_maps, consensus_labelers

def _parse_fragment_naming_options(fragment_names, fragments):
    r"""
    Helper method for the CLTs to understand what/how the user wants
    the fragments to be named
    Parameters
    ----------
    fragment_names : str or list
        If str, we assume it comes directly from the
        command line option --fragment_names,
        see :obj:`parsers._parser_add_fragment_names. Can be different
        things:
        * "" : fragment names will be named frag0,frag1,frag2 ... as needed
        * "None","none": fragment names will be None
        * comma-separated values, with as many values
        as fragments are in :obj:`fragments:
        If list, we do nothing (for compatibility with API use of CLI tools)
    fragments: list
        existing fragment definitions (iterables of residue indices)
         to apply the :obj:`fragment_names` to.
         Typically, :obj:`fragments` come from a call to :obj:`get_fragments`

    Returns
    -------
    fragment_names : list of strings

    fragments : list of fragments (only case "danger" was used, deprecated
    """
    #TODO fragment naming should be handled at the object level?

    if isinstance(fragment_names,(list, _np.ndarray)):
        return fragment_names
    if fragment_names == '':
        fragment_names = ['frag%u' % ii for ii in range(len(fragments))]
    elif fragment_names.lower()=="none":
        fragment_names = [None for __ in fragments]
    else:
        assert isinstance(fragment_names, str), "Argument --names invalid: %s" % fragment_names
        if 'danger' not in fragment_names.lower():
            fragment_names = [ff.strip(" ") for ff in fragment_names.split(",")]
            assert len(fragment_names) == len(
                fragments), "Mismatch between nr. fragments and fragment names %s vs %s (%s)" % (
                len(fragments), len(fragment_names), fragment_names)
            return fragment_names

        elif 'danger' in fragment_names.lower():
            raise NotImplementedError
            # browse older version to see what was here

    return fragment_names

# TODO mix and match with the color options of flareplots
def _parse_coloring_options(color_option, n,
                            default_color="blue",
                            color_cycle=my_frag_colors
                            ):
    r"""
    Helper function to parse user input and return a color list

    Parameters
    ----------
    color_option: str, list, bool, or None
       * str : return a list of len n with this color as each entry
       * list : assert len(list)>=len(n) and return it the first n-entries of it
       * bool : True  : create a list of len n that repeats :obj:`color_cycle`
                        as needed
       * bool : False : create a list of len n with :obj:`default_color` as entries
                        (same as :obj:`color_option` had equal to :obj:`default_color`)
       * None : same as false
    n : int
        Wanted number of colors
    default_color: str
        Any color matplotlib understands
    color_cycle: iterable of matplotlib colors

    Returns
    -------
    colors

    """
    assert isinstance(color_cycle,list)

    if str(color_option).lower()=="none":
        color_option = False


    if isinstance(color_option, bool):
        if not color_option:
            colors = [default_color for __ in range(n)]
        else:
            vec_idxs = _np.mod(_np.arange(n), len(my_frag_colors))
            colors = _np.array(color_cycle)[vec_idxs].tolist()
    elif isinstance(color_option, str):
        color_option = color_option.split(",")
        if len(color_option)==1:
            colors = [color_option[0] for __ in range(n)]
    elif isinstance(color_option,list):
        if len(color_option)>n:
            raise ValueError("Not enough input values %s for expected output of size n %u"%(color_option,n))
        else:
            colors = color_option[:n]

    return colors

# TODO Consider putting the figure instantiation also here
def _manage_timedep_ploting_and_saving_options(ctc_grp,# : ContactGroup,
                                               myfig,
                                               ctc_cutoff_Ang,
                                               output_desc,
                                               graphic_ext,
                                               output_dir=".",
                                               graphic_dpi=150,
                                               plot_timedep=True,
                                               separate_N_ctcs=False,
                                               table_ext=".dat",
                                               t_unit="ps",
                                               title=None,
                                               savefiles=True,
                                               ):
    r"""
    CLTs share this part and have the same options to save files of timedep plots

    Parameters
    ----------
    ctc_grp
    myfig
    ctc_cutoff_Ang
    output_desc
    graphic_ext
    output_dir
    graphic_dpi
    plot_timedep
    separate_N_ctcs
    table_ext
    t_unit

    Returns
    -------

    """
    firstname = output_desc.replace(" ","_")
    lastname = ""
    # TODO manage interface and sites appropiately
    if ctc_grp.is_neighborhood:
        lastname = "%s"%ctc_grp.anchor_res_and_fragment_str.replace('*', "")

    if title is None:
        title = output_desc #TODO consider using lastname

    fname_timedep = ('%s.%s.time_trace@%2.1f_Ang.%s' % (firstname,
                                                           lastname,
                                                           ctc_cutoff_Ang,
                                                           graphic_ext.strip("."))).replace("..", ".")

    fname_N_ctcs = ('%s.%s.time_trace@%2.1f_Ang.N_ctcs.%s' % (firstname,
                                                                 lastname,
                                                                 ctc_cutoff_Ang,
                                                                 graphic_ext.strip("."))).replace("..", ".")


    # Differentiate the type of figures we can have
    if len(myfig) == 0:
        fnames = []
    elif len(myfig) == 1:
        if plot_timedep:
            fnames = [fname_timedep]
        else:
            fnames = [fname_N_ctcs]
    elif len(myfig) == 2:
        fnames = [fname_timedep, fname_N_ctcs]

    if savefiles:
        for iname, ifig in zip(fnames, myfig):
            fname = _path.join(output_dir, iname)
            ifig.axes[0].set_title("%s" % title) # TODO consider firstname lastname
            ifig.savefig(fname, bbox_inches="tight", dpi=graphic_dpi)
            _plt.close(ifig)
            print(fname)

        # even if no figures were produced, the files should still be saved
        if plot_timedep:
            ctc_grp.save_trajs(output_desc, table_ext, output_dir, t_unit=t_unit, verbose=True)
        if separate_N_ctcs:
            ctc_grp.save_trajs(output_desc, table_ext, output_dir, t_unit=t_unit, verbose=True,
                               ctc_cutoff_Ang=ctc_cutoff_Ang)
    print()

#TODO introduce coverage exclusion labels
# like https://coverage.readthedocs.io/en/v4.5.x/excluding.html
# or refactor these methods into another test branch
"""
def _cmdstr2cmdtuple(cmd):
    return [ii.replace("nr", "nr ") for ii in cmd.replace("atomnr ", "atomnr").replace("'", "").split()]
"""

def _my_color_schemes(istr):
    return {"peter": ["red", "purple", "gold", "darkorange"],
            "hobat": ["m", "darkgreen", "darkorange", "navy"],
            "auto":  _plt.rcParams['axes.prop_cycle'].by_key()["color"]}[str(istr).lower()]

def _load_any_geom(geom):
    r"""
    Helper method for command-line-tools to create :obj:`mdtraj.Trajectories`
    from either filenames or :obj:`mdtraj.Trajectories` (i.e. do nothing)
    Parameters
    ----------
    geom : str or :obj:`mdtraj.Trajectory`

    Returns
    -------
    outgeom : :obj:`mdtraj.Trajectory`
    """
    if isinstance(geom, str):
        outgeom = _md.load(geom)
    else:
        outgeom = geom

    return outgeom

def _fragment_overview(a,labtype):
    r"""
    provide the CLTs BW_overview and CGN_overview

    Parameters
    ----------
    a : :obj:`argparse.Namespace` object
        Contains the arguments used by the user
    labtype : srt, "BW" or "CGN"
        lets the code know which :obj:`LabelerConsensus` to use

    Returns
    -------
    None
    """
    if labtype == "CGN":
        val = a.PDB_code_or_txtfile
        obj = _mdcnomenc.LabelerCGN(val, write_to_disk=a.write_to_disk)

    elif labtype == "BW":
        val = a.BW_uniprot_or_file
        if _path.exists(val):
            format = "%s"
        else:
            format = _signature(_mdcnomenc.LabelerBW).parameters["format"].default
        obj = _mdcnomenc.LabelerBW(val,
                  format=format,
                  write_to_disk=a.write_to_disk)
    else:
        raise ValueError("Don't know the consensus type %s, only 'BW' and 'CGN'"%labtype)

    if a.topology is not None:
        top = _md.load(a.topology).top
        map_conlab = obj.top2map(top)
        obj.top2defs(top, map_conlab=map_conlab, guess_consensus=a.fill_gaps)

        _mdcu.residue_and_atom.parse_and_list_AAs_input(a.AAs, top, map_conlab)
        if str(a.labels).lower() != "none":
            labels = [aa.strip(" ") for aa in a.labels.split(",")]
            conlab2residx = obj.conlab2residx(top, map=map_conlab)
            for lab in labels:
                for match in _filter(list(conlab2residx.keys()),lab):
                    idx = conlab2residx[match]
                    rr = top.residue(idx)
                    print(idx,rr, map_conlab[idx])

        if a.print_conlab:
            for ii, ilab in enumerate(map_conlab):
                print(ii, top.residue(ii), ilab)
    else:
        for key, frag in obj.fragments.items():
            print("fragment %s with %u AAs:"%(key, len(frag)))
            from pandas import DataFrame as _DF
            idf = _DF.from_dict({"residue"  : frag,
                                 "consensus": obj.fragments_as_conlabs[key]})

            textblocks = [['%-25s'%iline for iline in idf.loc[idxs].to_string().splitlines()] for idxs in _mdcu.lists.re_warp(_np.arange(len(idf)),10)]
            for ii in range(len(textblocks[0])):
                line = ''
                for tb in textblocks:
                    try:
                        line += ' | %s'%tb[ii]
                    except IndexError as E:
                        pass
                print(line)
            
def residue_neighborhoods(residues,
                          topology,
                          trajectories=None,
                          res_idxs=False,
                          ctc_cutoff_Ang=3.5,
                          stride=1,
                          ctc_control=5,
                          n_nearest=4,
                          chunksize_in_frames=10000,
                          nlist_cutoff_Ang=15,
                          n_smooth_hw=0,
                          ask=True,
                          #TODO re-think whether ask makes sense anymore
                          sort=True,
                          pbc=True,
                          ylim_Ang=15,
                          fragments=["lig_resSeq+"],
                          fragment_names="",
                          fragment_colors=None,
                          graphic_ext=".pdf",
                          table_ext=".dat",
                          BW_uniprot=None,
                          CGN_PDB=None,
                          output_dir='.',
                          output_desc='neighborhood',
                          t_unit='ns',
                          curve_color="auto",
                          gray_background=False,
                          graphic_dpi=150,
                          short_AA_names=False,
                          allow_same_fragment_ctcs=True,
                          save_nomenclature_files=False,
                          plot_timedep=True,
                          n_cols=4,
                          distro=False,
                          n_jobs=1,
                          separate_N_ctcs=False,
                          accept_guess=False,
                          switch_off_Ang=None,
                          plot_atomtypes=False,
                          savefiles=True,
                          ):
    r"""Per-residue neighborhoods based on contact frequencies between pairs
    of residues.

    A neighborhood is a :obj:`mdciao.contacts.ContactGroup`-object containing a set of
    :obj:`mdciao.contacts.ContactPair`-objects with a shared residue,
    called the `anchor_residue`.

    The contact frequencies will be printed, plotted and saved. The residue-residue
    distance time-traces used for their computation will be also returned

    Note
    ----
    The time-independent figures (e.g. "neighborhood.overall@3.5_Ang.pdf") are always shown
    whereas the time-dependent figures (e.g. "neighborhood.GDP395.time_trace@3.5_Ang.pdf")
    are never shown, because the number of time-traces becomes very high very quickly.
    It's easier to look at them with an outside viewer.


    The user may be prompted when necessary,
    although this behaviour can be turned off with :obj:`accept_guess`

    Input can be from disk and/or from memory (see below).

    Can be parallelized up to the number of used trajectories.

    Many other optional parameters are exposed to allow fine-tuning of the
    computing, plotting, printing, and saving. Additional information can be regarding nomenclature,
    fragmentation heuristics and/or naming and or/coloring, residue labeling, time-trace
    averaging, data-streaming,

    Parameters
    ----------
    residues : int, iterable of ints or str
        The residue(s) for which the neighborhood will be computed.
        This input is pretty flexible wrt to strings and numbers,
        which are interpreted as sequence indices unless
        :obj:`res_idxs` is True
        Valid inputs are are:
         * residues = [1,10,11,12]
         * residues = '1,10,11,12'
         * residues = '1,10-12'
         * residues = [1]
         * residues = 1
         * residues = '1'
         * residues = '1,10-12,GLU*,GDP*,E30'
         Please refer to :obj:`mdciao.utils.residue_and_atom.rangeexpand_residues2residxs`
         for more info
    topology : str or :obj:`mdtraj.Trajectory`
        This geometry is used as a topology and
        as a reference geometry for :obj:`nlist_cutoff_Ang`.
        If str, it's the full path to the topology file,
        e.g. 'sims/prot.pdb')
    trajectories : str, :obj:`mdtraj.Trajectory`, or None
        The MD-trajectories to calculate the frequencies from.
        This input is pretty flexible. For more info check
        :obj:`mdciao.utils.str_and_dict.get_sorted_trajectories`.
        Accepted values are:
         * pattern, e.g. "*.ext"
         * one string containing a filename
         * list of filenames
         * one :obj:`mdtraj.Trajectory` object
         * list of :obj:`mdtraj.Trajectory` objects
         * None
        If None, the :obj:`mdtraj.Trajectory` object
        given in :obj:`topology` is used as trajectories
    Other Parameters
    ----------------
    res_idxs : bool, default is False
        Whether the indices of :obj:`residues` should be understood as
         * zero-indexed, residue serial indices or
         * residue sequence, eg. 30 in GLU30, this is called 'resSeq'
         in an :obj:`mdtraj.core.Residue`-object
    ctc_cutoff_Ang : float, default is 3.5
        Any residue-residue distance is considered a contact if d<=ctc_cutoff_Ang
    stride : int, default is 1
        Stride the input data by this number of frames
    ctc_control : int or float, default is 5
        Control the number of reported contacts. Can be an
        integer (keep the first n contacts) or a float
        representing a fraction [0,1] of the total number of
        contacts.Default is 5.
    n_nearest : int, default is 4
        Exclude these many bonded neighbors for each residue, i.e
    chunksize_in_frames : int, default is 10000
        Stream through the trajectory data in chunks of this many frames
        Can lead to memory errors if :obj:`n_jobs` makes it so that
        e.g. 4 trajectories of 10000 frames each are loaded to memory
        and their residue-residue distances computed
    nlist_cutoff_Ang : int, default is 15
        Before computing the residue-residue distance for all frames,
        neighbor-list is created, for each residue, that includes
        the residues up to :obj:`nlist_cutoff_Ang` from the residue.
        Increase this parameters (e.g. to 30) if you expect large conformational
        changes and/or the geometry in :obj:`topology`
    n_smooth_hw: int, default is 0
        Plots of the time-traces will be smoothed using a window
        of 2*n_smooth_hw
    ask : bool, default is True
        Be interactive and prompt the user when it is needed
    sort : bool, default is True
        Sort the input :obj:`residues` according to their indices
    pbc : bool, default is True
        Use periodic boundary conditions
    ylim_Ang : float, default is 15
        Limit in Angstrom of the y-axis of the time-traces.
        Default is 15. Switch to any other float or 'auto'
        for automatic scaling
    fragments : list, default is ["lig_resSeq+"]
        Fragment control. For compatibility reasons, it has
        to be a list, even if it only has one element.
        There exist several input modes:

        * Use some fragmentation heuristic, e.g.
         ["lig_resSeq+"]. See :obj:`mdciao.fragments.get_fragments` for other heuristics
        * Input fragments directly as iterables of residue indices, e.g.
         [np.arange(10),np.arange(10,20)]
        * Input fragments as ranges using strings, e.g.
         ["0-10","10-20", "R30-GLU40"]
        You can combine both last options, e.g. [range(10),"20-30"].
        The resulting fragments need not cover all of the topology,
        they only need to not overlap.
    fragment_names : string or list of strings, default is ""
        If string, it has to be a list of comma-separated values.
        If you want unnamed fragments, use None, "None", or "".
        Has to contain names for all fragments that result from
        :obj:`fragments` or more.
        mdciao wil try to use :obj:`replace4latex`
        to generate LaTeX expressions from stuff like "Galpha"
        You can use fragment_names="None" or "" to avoid using fragment names
    fragment_colors : None, boolean or list, default is None
        Assign colors to fragments. These colors will be used
        to color-code the frequency bars. If True, colors
        will be automatically selected, otherwise picked
        from the list. Use with cautions, plots
        get shrill quickly
    graphic_ext : str, default is ".pdf"
        The extension (=format) of the saved figures
    table_ext : str, default is ".dat"
        The extension (=format) of the saved tables
    BW_uniprot : str or :obj:`mdciao.nomenclature.LabelerBW`, default is None
        Try to find Ballesteros-Weinstein definitions. If str, e.g. "adrb2_human",
        try to locate a local filename or do a web lookup in the GPCRdb.
        If `mdciao.nomenclature.Labeler_BW`, use this object direcly
        (allows for object re-use when in API mode)
        See :obj:`mdciao.nomenclature` for more info and references.
    CGN_PDB : str or :obj:`mdciao.nomenclature.LabelerCGN`, default is None
        Try to find Common G-alpha Numbering definitions. If str, e.g. "3SN6",
        try to locate local filenames ("3SN6.pdb", "CGN_3SN6.txt") or do web lookups
        in https://www.mrc-lmb.cam.ac.uk/CGN/ and http://www.rcsb.org/.
        If :obj:`mdciao.nomenclature.LabelerCGN', use this object direcly
        (allows for object re-use when in API mode)
        See :obj:`mdciao.nomenclature` for more info and references.
    output_dir : str, default is '.'
        directory to which the results are written.
    output_desc : str, default is 'neighborhood'
        Descriptor for output files.
    t_unit : str, default is 'ns'
        Unit used for the temporal axis.
    curve_color : str, default is 'auto'
        Type of color used for the curves. Alternatives are "P" or "H"
    gray_background : bool, default is False
        Use gray background when using smoothing windows
    graphic_dpi : int, default is 150
        Dots per Inch (DPI) of the graphic output. Only has
        an effect for bitmap outputs.
    short_AA_names : bool, default is False
        Use one-letter aminoacid names when possible, e.g.
        K145 insted of Lys145.
    allow_same_fragment_ctcs : bool, default is True
        Allow contacts whithin the same fragment.
    save_nomenclature_files : bool, default is False
        Save available nomenclature definitions to disk so
        that they can be accessed locally in later uses.
    plot_timedep : bool, default is True
        Plot and save time-traces of the contacts
    n_cols : int, default is 4
        number of columns of the overall plot.
    distro : bool, default is False
        Plot distance distributions instead of contact bar
        plots
    n_jobs : int, default is 1
        Number of processors to use. The parallelization is
        done over trajectories and not over contacts, beyond
        n_jobs>n_trajs parallelization will not have any
        effect.
    separate_N_ctcs : bool, default is False
        Separate the plot with the total number contacts
        from the time-trace plot.
    accept_guess : bool, default is False
        Accept mdciao's guesses regarding fragment
        identification using nomenclature labels
    switch_off_Ang : NoneType, default is None
        Use a linear switchoff instead of a crisp one.
    plot_atomtypes : bool, default is False
        Add the atom-types to the frequency bars by
        'hatching' them. '--' is sidechain-sidechain '|' is
        backbone-backbone '\' is backbone-sidechain '/' is
        sidechain-backbone. See Fig XX for an example
    savefiles : bool, default is True
        Write the figures and tables to disk.


    Returns
    -------
    out_dict : dict
        * neighborhoods : dictionary keyed by unique, zero-indexed residue indices.
         The values are :obj:`mdciao.contacts.ContactGroup` objects
        * ctc_idxs : 2D np.ndarray with the residue indices of the contact pairs within obj`:nlist_cutoff_Ang` in at least one frame
        * ctcs_trajs : list of per-traj 2D np.ndarrays with the mindist between the residues of "ctc_idxs"
        * time_array : list of per-traj time-arrays

        Usually, only *neighborhoods* is usefull, other entries are there for debugging

    """

    # Input control residues
    if residues is None:
        print("You have to provide some residue input via the --residues option")
        return None

    _offer_to_create_dir(output_dir)

    # String comparison to allow for command line argparse-use directly
    if str(table_ext).lower() != 'none' and str(table_ext).lower().strip(".") in ["dat", "txt", "xlsx"]:
        table_ext = str(table_ext).lower().strip(".")
    else:
        table_ext = None

    # More input control
    ylim_Ang=_np.float(ylim_Ang)
    if trajectories is None:
        trajectories = topology
    xtcs = _mdcu.str_and_dict.get_sorted_trajectories(trajectories)
    print("Will compute contact frequencies for :\n%s"
          "\n with a stride of %u frames" % (_mdcu.str_and_dict.inform_about_trajectories(xtcs), stride))

    refgeom = _load_any_geom(topology)

    fragments_as_residue_idxs, __ = _mdcfrg.fragments._fragments_strings_to_fragments(fragments, refgeom.top, verbose=True)
    fragment_names = _parse_fragment_naming_options(fragment_names, fragments_as_residue_idxs)
    fragment_colors = _parse_coloring_options(fragment_colors,len(fragment_names))

    # Do we want BW definitions
    BWresidx2conlab = _parse_consensus_option(BW_uniprot, 'BW', refgeom.top, fragments_as_residue_idxs,
                                              write_to_disk=save_nomenclature_files,
                                              accept_guess=accept_guess)

    # Dow we want CGN definitions:
    CGNresidx2conlab = _parse_consensus_option(CGN_PDB, 'CGN', refgeom.top, fragments_as_residue_idxs,
                                               write_to_disk=save_nomenclature_files,
                                               accept_guess=accept_guess)

    #TODO refactor into rangeexpand_residues2residxs?
    # for compatibility for interactive execution
    if not isinstance(residues,str):
        residues= ','.join([str(ii) for ii in _mdcu.lists.force_iterable(residues)])
    res_idxs_list = _mdcu.residue_and_atom.rangeexpand_residues2residxs(residues, fragments_as_residue_idxs, refgeom.top,
                                                  interpret_as_res_idxs=res_idxs,
                                                  sort=sort,
                                                  pick_this_fragment_by_default=None,
                                                  additional_naming_dicts={"BW": {ii:val for ii, val in enumerate(BWresidx2conlab)},
                                                                           "CGN": {ii:val for ii, val in enumerate(CGNresidx2conlab)}}
                                                  )
    print("\nWill compute neighborhoods for the residues")
    print("%s" % residues)
    print("excluding %u nearest neighbors\n" % n_nearest)

    print('%10s  %10s  %10s  %10s %10s %10s' % tuple(("residue  residx fragment  resSeq BW  CGN".split())))
    for idx in res_idxs_list:
        print('%10s  %10u  %10u %10u %10s %10s' % (refgeom.top.residue(idx), idx, _mdcu.lists.in_what_fragment(idx,
                                                                                                   fragments_as_residue_idxs),
                                                   idx,
                                                   BWresidx2conlab[idx], CGNresidx2conlab[idx]))

    # Create a neighborlist
    nl = _mdcu.bonds.bonded_neighborlist_from_top(refgeom.top, n=n_nearest)

    # Use it to prune the contact indices
    ctc_idxs = _np.vstack(
        [[_np.sort([val, ii]) for ii in range(refgeom.top.n_residues) if ii not in nl[val] and ii != val] for val in
         res_idxs_list])

    # Can we have same-fragment contacts
    if not allow_same_fragment_ctcs:
        fragment_idxs = [[_mdcu.lists.in_what_fragment(idx, fragments_as_residue_idxs) for idx in pair] for pair in ctc_idxs]
        ctc_idxs = [ctc_idxs[ii] for (ii,pair) in enumerate(fragment_idxs) if pair[0]!=pair[1]]


    print(
        "\nPre-computing likely neighborhoods by reducing the neighbor-list to %u Angstrom in the reference geom %s..." % (
            nlist_cutoff_Ang, topology), end="", flush=True)
    ctcs, ctc_idxs = _md.compute_contacts(refgeom, _np.vstack(ctc_idxs), periodic=pbc)
    print("done!")

    ctc_idxs_small = _np.argwhere(ctcs[0] < nlist_cutoff_Ang / 10).squeeze()
    _, ctc_idxs_small = _md.compute_contacts(refgeom, ctc_idxs[ctc_idxs_small])
    ctc_idxs_small = _mdcu.lists.unique_list_of_iterables_by_tuple_hashing(ctc_idxs_small)

    print("From %u potential distances, the neighborhoods have been "
          "reduced to only %u potential contacts.\n"
          "If this number is still too high (i.e. the computation is too slow)"
          ", consider using a smaller nlist_cutoff_Ang " % (
              len(ctc_idxs), len(ctc_idxs_small)))

    ctcs_trajs, time_arrays, at_pair_trajs = _mdcctcs.trajs2ctcs(xtcs, refgeom.top, ctc_idxs_small, stride=stride,
                                                       chunksize=chunksize_in_frames, return_times_and_atoms=True,
                                                       consolidate=False,
                                                       n_jobs=n_jobs,
                                                       )
    print() # to make sure we don't overwrite output
    actcs = _np.vstack(ctcs_trajs)
    if switch_off_Ang is None:
        ctcs_mean = _np.mean(actcs < ctc_cutoff_Ang / 10, 0)
    else:
        ctcs_mean = _np.mean(_mdcctcs._linear_switchoff(actcs, ctc_cutoff_Ang / 10, switch_off_Ang / 10),0)

    final_look = _mdcctcs.select_and_report_residue_neighborhood_idxs(ctcs_mean, res_idxs_list,
                                                                      fragments_as_residue_idxs, ctc_idxs_small,
                                                                      refgeom.top,
                                                                      interactive=False,
                                                                      ctcs_kept=ctc_control)

    # Create the neighborhoods as groups of contact_pair objects
    neighborhoods = {}
    empty_CGs = []
    for res_idx, val in final_look.items():
        CPs = []
        for idx in val:
            pair = ctc_idxs_small[idx]
            consensus_labels = [_mdcnomenc.choose_between_consensus_dicts(idx, [BWresidx2conlab, CGNresidx2conlab]) for idx in pair]
            fragment_idxs = [_mdcu.lists.in_what_fragment(idx, fragments_as_residue_idxs) for idx in pair]
            CPs.append(_mdcctcs.ContactPair(pair,
                                   [itraj[:, idx] for itraj in ctcs_trajs],
                                   time_arrays,
                                   top=refgeom.top,
                                   anchor_residue_idx=res_idx,
                                   consensus_labels=consensus_labels,
                                   trajs=xtcs,
                                   fragment_idxs=fragment_idxs,
                                   fragment_names=[fragment_names[idx] for idx in fragment_idxs],
                                   fragment_colors=[fragment_colors[idx] for idx in fragment_idxs],
                                   atom_pair_trajs=[itraj[:, [idx * 2, idx * 2 + 1]] for itraj in at_pair_trajs]
                                   ))
        try:
            neighborhoods[res_idx] = _mdcctcs.ContactGroup(CPs)
        except NotImplementedError as e:
            print(e)
            empty_CGs.append(res_idx)
            neighborhoods[res_idx] = None
    if len(empty_CGs) == len(final_look):
        print("No residues have any neighbors at %2.1f Ang. No output produced." % ctc_cutoff_Ang)
        return
    elif len(empty_CGs)>0:
        print("The following residues have no neighbors at %2.1f Ang, their frequency histograms will be empty"%ctc_cutoff_Ang)
        print("\n".join([str(refgeom.top.residue(ii)) for ii in empty_CGs]))

    panelheight = 3
    n_cols = _np.min((n_cols, len(res_idxs_list)))
    n_rows = _np.ceil(len(res_idxs_list) / n_cols).astype(int)
    panelsize = 4
    panelsize2font = 3.5
    bar_fig, bar_ax = _plt.subplots(n_rows, n_cols,
                                    sharex=True,
                                    sharey=True,
                                    figsize=(n_cols * panelsize * 2, n_rows * panelsize), squeeze=False)

    # One loop for the histograms
    _rcParams["font.size"]=panelsize*panelsize2font
    for jax, ihood in zip(bar_ax.flatten(),
                                   neighborhoods.values()):
        if ihood is not None:
            if distro:
                ihood.plot_distance_distributions(nbins=20,
                                                  jax=jax,
                                                  label_fontsize_factor=panelsize2font/panelsize,
                                                  shorten_AAs=short_AA_names,
                                                  ctc_cutoff_Ang=ctc_cutoff_Ang,
                                                  n_nearest= n_nearest
                                                  )
            else:
                ihood.plot_neighborhood_freqs(ctc_cutoff_Ang,
                                              n_nearest,
                                              switch_off_Ang=switch_off_Ang,
                                              jax=jax,
                                              xmax=_np.max([ihood.n_ctcs for ihood in neighborhoods.values() if ihood is not None]),
                                              label_fontsize_factor=panelsize2font / panelsize,
                                              shorten_AAs=short_AA_names,
                                              color=ihood.partner_fragment_colors,
                                              plot_atomtypes=plot_atomtypes
                                              )

    if not distro:
        xmax = _np.max([jax.patches[-1].get_x()+jax.patches[-1].get_width()/2 for jax in bar_ax.flatten()
                        if len(jax.patches)>0])+.5
        [iax.set_xlim([-.5, xmax]) for iax in bar_ax.flatten()]
    bar_fig.tight_layout(h_pad=2, w_pad=0, pad=0)
    fname = "%s.overall@%2.1f_Ang.%s" % (output_desc, ctc_cutoff_Ang, graphic_ext.strip("."))
    fname = _path.join(output_dir, fname)
    if savefiles:
        bar_fig.savefig(fname, dpi=graphic_dpi)
        print("The following files have been created")
        print(fname)

    neighborhoods = {key:val for key, val in neighborhoods.items() if val is not None}
    print(fname)
    # TODO undecided about this
    # TODO this code is repeated in sites...can we abstract this oafa?
    if table_ext is not None and savefiles:
        for ihood in neighborhoods.values():
            fname = '%s.%s@%2.1f_Ang.%s' % (output_desc,
                                            ihood.anchor_res_and_fragment_str.replace('*', ""),
                                            ctc_cutoff_Ang,
                                            table_ext)
            fname = _path.join(output_dir, fname)

            #TODO can't the frequency_spreadsheet handle this now?
            # TODO this code is repeated in sites...can we abstract this oafa?
            if table_ext=='xlsx':
                ihood.frequency_spreadsheet(ctc_cutoff_Ang, fname,
                                            switch_off_Ang=switch_off_Ang,
                                            write_interface=False,
                                            by_atomtypes=True,
                                            # AA_format="long",
                                            split_label="join"
                                            )
            else:
                with open(fname, 'w') as f:
                    f.write(ihood.frequency_str_ASCII_file(ctc_cutoff_Ang, switch_off_Ang=switch_off_Ang))
            print(fname)

    #TODO make a method out of this to use in all CLTs
    # TODO perhaps use https://github.com/python-attrs/attrs
    # to avoid boilerplate
    # Thi is very ugly
    if plot_timedep or separate_N_ctcs:
        for ihood in neighborhoods.values():
            # TODO this plot_N_ctcs and skip_timedep is very bad, but ATM my only chance without major refactor
            # TODO perhaps it would be better to bury dt in the plotting directly?
            myfig = ihood.plot_timedep_ctcs(panelheight,
                                            color_scheme=_my_color_schemes(curve_color),
                                            ctc_cutoff_Ang=ctc_cutoff_Ang,
                                            switch_off_Ang=switch_off_Ang,
                                            dt=_mdcu.str_and_dict.tunit2tunit["ps"][t_unit],
                                            gray_background=gray_background,
                                            n_smooth_hw=n_smooth_hw,
                                            plot_N_ctcs=True,
                                            pop_N_ctcs=separate_N_ctcs,
                                            shorten_AAs=short_AA_names,
                                            skip_timedep=not plot_timedep,
                                            t_unit=t_unit,
                                            ylim_Ang=ylim_Ang,
                                            )
            # One title for all axes on top
            title = ihood.anchor_res_and_fragment_str
            if short_AA_names:
                title = ihood.anchor_res_and_fragment_str_short
            if n_nearest >0:
                title += "\n%u nearest bonded neighbors excluded" % (n_nearest)
            _manage_timedep_ploting_and_saving_options(ihood, myfig,
                                                       ctc_cutoff_Ang,
                                                       output_desc,
                                                       graphic_ext,
                                                       output_dir=output_dir,
                                                       graphic_dpi=graphic_dpi,
                                                       plot_timedep=plot_timedep,
                                                       table_ext=table_ext,
                                                       t_unit=t_unit,
                                                       separate_N_ctcs=separate_N_ctcs,
                                                       title=title
                                                       )

    return {"ctc_idxs": ctc_idxs_small,
            'ctcs_trajs': ctcs_trajs,
            'time_array': time_arrays,
            "neighborhoods": neighborhoods}

def interface(
        topology=None,
        trajectories=None,
        frag_idxs_group_1=None,
        frag_idxs_group_2=None,
        BW_uniprot="None",
        CGN_PDB="None",
        chunksize_in_frames=10000,
        ctc_cutoff_Ang=3.5,
        curve_color="auto",
        fragments=['lig_resSeq+'],
        fragment_names="",
        graphic_dpi=150,
        graphic_ext=".pdf",
        gray_background=False,
        interface_cutoff_Ang=35,
        ctc_control=20,
        n_smooth_hw=0,
        output_desc="interface",
        output_dir=".",
        short_AA_names=False,
        stride=1,
        t_unit="ns",
        plot_timedep=True,
        accept_guess=False,
        n_jobs=1,
        n_nearest=0,
        sort_by_av_ctcs=True,
        scheme="closest-heavy",
        separate_N_ctcs=False,
        table_ext=None,
        title=None,
        min_freq=.10,
        contact_matrix=True,
        cmap='binary',
        flareplot=True,
        sparse_flare_frags = True,
        savefiles=True,
        save_nomenclature_files=False
):
    r"""Contact-frequencies between residues belonging
    to different fragments of the molecular topology

    Parameters
    ----------
    topology
    trajectories
    frag_idxs_group_1
    frag_idxs_group_2
    BW_uniprot
    CGN_PDB
    chunksize_in_frames
    ctc_cutoff_Ang
    curve_color
    fragments
    fragment_names
    graphic_dpi
    graphic_ext
    gray_background
    interface_cutoff_Ang
    ctc_control
    n_smooth_hw
    output_desc
    output_dir
    short_AA_names
    stride
    t_unit
    plot_timedep
    accept_guess
    n_jobs
    n_nearest
    sort_by_av_ctcs
    scheme
    separate_N_ctcs
    table_ext
    title
    min_freq
    sparse_flare_frags: bool, default is True
        When deciding what fragments to put on
        the flareplot, use only those fragments
        where at least one residue is involved
        in the interface

    Returns
    -------

    """
    if str(title).lower()=="none":
        title = output_desc

    output_desc = output_desc.strip(".")
    _offer_to_create_dir(output_dir)
    graphic_ext = graphic_ext.strip(".")

    if trajectories is None:
        trajectories = topology
    xtcs = _mdcu.str_and_dict.get_sorted_trajectories(trajectories)
    print("Will compute contact frequencies for trajectories:\n%s"
          "\n with a stride of %u frames" % (_mdcu.str_and_dict.inform_about_trajectories(xtcs), stride))

    refgeom = _load_any_geom(topology)

    # TODO this is a backwards-compat issue that should be handled elsewhere
    if not isinstance(fragments[0],str):
        fragments= [','.join([str(ii) for ii in _mdcu.lists.force_iterable(ifrag)]) for ifrag in fragments]
    fragments_as_residue_idxs, user_wants_consenus = _mdcfrg.fragments._fragments_strings_to_fragments(fragments, refgeom.top, verbose=True)
    fragment_names = _parse_fragment_naming_options(fragment_names, fragments_as_residue_idxs)
    fragment_defs, consensus_maps, consensus_labelers = \
        _parse_consensus_options_and_return_fragment_defs({"BW": BW_uniprot,
                                                           "CGN": CGN_PDB},
                                                          refgeom.top,
                                                          fragments_as_residue_idxs,
                                                          accept_guess=accept_guess,
                                                          save_nomenclature_files=save_nomenclature_files)
    if user_wants_consenus:
        intf_frags_as_residxs, \
        intf_frags_as_str_or_keys  = _mdcfrg.frag_dict_2_frag_groups(fragment_defs, ng=2)

    else:
        intf_frags_as_residxs, \
        intf_frags_as_str_or_keys   = _mdcfrg.frag_list_2_frag_groups(fragments_as_residue_idxs,
                                                               frag_idxs_group_1, frag_idxs_group_2,
                                                               )
    intersect = list(set(intf_frags_as_residxs[0]).intersection(intf_frags_as_residxs[1]))
    assert len(intersect) == 0, ("Some_residxs appear in both members of the interface %s, "
                                 "this is not possible" % intersect)
    ctc_idxs = _np.vstack(list(_iterpd(intf_frags_as_residxs[0], intf_frags_as_residxs[1])))

    # Remove self-contacts
    ctc_idxs = _np.vstack([pair for pair in ctc_idxs if pair[0]!=pair[1]])

    # Create a neighborlist
    if n_nearest>0:
        print("Excluding contacts between %u nearest neighbors"%n_nearest)
        nl = _mdcu.bonds.bonded_neighborlist_from_top(refgeom.top, n=n_nearest)
        ctc_idxs = _np.vstack([(ii,jj) for ii,jj in ctc_idxs if jj not in nl[ii]])

    print("\nComputing distances in the interface between fragments\n%s\nand\n%s.\n"
          "The interface is defined by the residues within %3.1f "
          "Angstrom of each other in the reference topology.\n"
          "Computing interface..."
          % ('\n'.join(_twrap(', '.join(['%s' % gg for gg in intf_frags_as_str_or_keys[0]]))),
             '\n'.join(_twrap(', '.join(['%s' % gg for gg in intf_frags_as_str_or_keys[1]]))),
             interface_cutoff_Ang), end="")

    ctcs, ctc_idxs = _md.compute_contacts(refgeom[0], _np.vstack(ctc_idxs))
    print("done!")

    ctc_idxs_receptor_Gprot = ctc_idxs[_np.argwhere(ctcs[0] < interface_cutoff_Ang / 10).squeeze()]

    interface_residx_short = [list(set(ctc_idxs_receptor_Gprot[:,0]).intersection(intf_frags_as_residxs[0])),
                              list(set(ctc_idxs_receptor_Gprot[:,1]).intersection(intf_frags_as_residxs[1]))]

    print()
    print(
        "From %u potential group_1-group_2 distances, the interface was reduced to only %u potential contacts.\nIf this "
        "number is still too high (i.e. the computation is too slow) consider using a smaller interface cutoff" % (
        len(ctc_idxs), len(ctc_idxs_receptor_Gprot)))
    print()
    ctcs, times, at_pair_trajs = _mdcctcs.trajs2ctcs(xtcs, refgeom.top, ctc_idxs_receptor_Gprot,
                                 stride=stride, return_times_and_atoms=True,
                                 consolidate=False,
                                 chunksize=chunksize_in_frames,
                                 n_jobs=n_jobs,
                                 progressbar=True,
                                 scheme=scheme
                                 )

    # Stack all data
    actcs = _np.vstack(ctcs)

    # Get frequencies so that we don't create unnecessary ctc objects
    ctcs_bin = (actcs <= ctc_cutoff_Ang / 10).astype("int").sum(0)
    ctc_frequency = ctcs_bin / actcs.shape[0]
    tot_freq = ctc_frequency.sum()
    order = _np.argsort(ctc_frequency)[::-1]
    ctc_objs = []
    if float(ctc_control).is_integer(): # float is needed in case the API-call gets an int passed
        n_ctcs = int(ctc_control)
    else:
        n_ctcs = _mdcctcs.contacts._idx_at_fraction(ctc_frequency[order], ctc_control)
    #TODO still unsure about where it's best to put this
    _mdcctcs.contacts._contact_fraction_informer(n_ctcs, ctc_frequency[order], or_frac=.9)
    for ii, idx in enumerate(order[:n_ctcs]):
        ifreq = ctc_frequency[idx]
        if ifreq > min_freq:
            pair = ctc_idxs_receptor_Gprot[idx]
            consensus_labels = [_mdcnomenc.choose_between_consensus_dicts(idx, consensus_maps,
                                                                no_key=None) for idx in pair]
            fragment_idxs = [_mdcu.lists.in_what_fragment(idx, fragments_as_residue_idxs) for idx in pair]
            ctc_objs.append(_mdcctcs.ContactPair(pair,
                                        [itraj[:, idx] for itraj in ctcs],
                                        times,
                                        top=refgeom.top,
                                        consensus_labels=consensus_labels,
                                        trajs=xtcs,
                                        fragment_idxs=fragment_idxs,
                                        fragment_names=[fragment_names[idx] for idx in fragment_idxs],
                                        atom_pair_trajs=[itraj[:, [idx*2, idx*2+1]] for itraj in at_pair_trajs]
                                        ))
            cum_freq = ctc_frequency[order[:ii+1]].sum()
            #print(ii, ifreq.round(2), cum_freq.round(2), (cum_freq.sum()/tot_freq*100).round(2))

    ctc_grp_intf = _mdcctcs.ContactGroup(ctc_objs,
                                interface_residxs=interface_residx_short)
    print()
    print(ctc_grp_intf.frequency_dataframe(ctc_cutoff_Ang).round({"freq":2, "sum":2}))
    print()
    dfs = ctc_grp_intf.frequency_sum_per_residue_names_dict(ctc_cutoff_Ang,
                                                            list_by_interface=True,
                                                            return_as_dataframe=True,
                                                            sort=sort_by_av_ctcs)
    print(dfs[0].round({"freq":2}))
    print()
    print(dfs[1].round({"freq":2}))
    panelheight = 3
    n_cols = 1
    n_rows = 2
    panelsize = 4
    panelsize2font = 3.5
    fudge = 7
    histofig, histoax = _plt.subplots(n_rows, n_cols, sharex=True, sharey=False,
                                      figsize=(n_cols * panelsize * _np.ceil(ctc_grp_intf.n_ctcs/fudge),
                                              n_rows * panelsize),
                                      )

    # One loop for the histograms
    _rcParams["font.size"] = panelsize * panelsize2font
    ctc_grp_intf.plot_freqs_as_bars(ctc_cutoff_Ang,
                                    title,
                                    jax=histoax[0],
                                    xlim=_np.min((n_ctcs, ctc_grp_intf.n_ctcs)),
                                    label_fontsize_factor=panelsize2font / panelsize,
                                    shorten_AAs=short_AA_names,
                                    truncate_at=min_freq,
                                    total_freq=tot_freq
                                    )

    ctc_grp_intf.plot_frequency_sums_as_bars(ctc_cutoff_Ang,
                                             title,
                                             jax=histoax[1],
                                             list_by_interface=True,
                                             label_fontsize_factor=panelsize2font / panelsize,
                                             truncate_at=.05,
                                             sort=sort_by_av_ctcs,
                                             )
    histofig.tight_layout(h_pad=2, w_pad=0, pad=0)

    # TODO manage filenames better, avoid overwriting here when file exists
    fname_wo_ext = "%s.overall@%2.1f_Ang" % (output_desc.replace(" ","_"), ctc_cutoff_Ang)
    fname_wo_ext = _path.join(output_dir, fname_wo_ext)
    fname_histo = ".".join([fname_wo_ext, graphic_ext])
    fname_excel = ".".join([fname_wo_ext,"xlsx"])
    fname_dat = ".".join([fname_wo_ext, "dat"])
    fname_pdb = ".".join([fname_wo_ext, "as_bfactors.pdb"])
    fname_mat   = fname_histo.replace("overall@", "matrix@")
    fname_flare = '.'.join([fname_wo_ext.replace("overall@", "flare@"),'pdf'])

    if savefiles:
        print("The following files have been created")
        histofig.savefig(fname_histo, dpi=graphic_dpi, bbox_inches="tight")
        print(fname_histo)
        ctc_grp_intf.frequency_spreadsheet(ctc_cutoff_Ang, fname_excel, sort=sort_by_av_ctcs)
        print(fname_excel)
        ctc_grp_intf.frequency_str_ASCII_file(ctc_cutoff_Ang, ascii_file=fname_dat)
        print(fname_dat)
        ctc_grp_intf.frequency_to_bfactor(ctc_cutoff_Ang, fname_pdb, refgeom,
                                          #interface_sign=True
                                          )
        print(fname_pdb)

        #TODO bury this in plots?
        if contact_matrix:
            ifig, iax = ctc_grp_intf.plot_interface_frequency_matrix(ctc_cutoff_Ang,
                                                                     colorbar=True,
                                                                     grid=True,
                                                                     cmap=cmap)

            iax.set_title("'%s'  as contact matrix" % _mdcu.str_and_dict.replace4latex(title),
                          fontsize = iax.get_xticklabels()[0].get_fontsize()*2)
            ifig.tight_layout()
            ifig.savefig(fname_mat)
            print(fname_mat)
    if flareplot:
        flare_frags, flare_labs = fragments_as_residue_idxs, None # Not sure about what's best here
        if len(consensus_labelers) > 0:
            # This is because frag_defs could be missing a lot of stuff depending
            # on user input, check the next method's doc
            consensus_frags = _mdcnomenc.compatible_consensus_fragments(refgeom.top, consensus_maps,
                                                             consensus_labelers.values())

            flare_frags, flare_labs = _mdcfrg.splice_orphan_fragments(list(consensus_frags.values()),
                                                                      list(consensus_frags.keys()),
                                                                      highest_res_idx=refgeom.top.n_residues - 1,
                                                                      orphan_name=""
                                                                      )
        if sparse_flare_frags:
            idxs = [ii for ii, ff in enumerate(flare_frags) if len(_np.intersect1d(_np.hstack(intf_frags_as_residxs), ff))>0]
            flare_frags = [flare_frags[ii] for ii in idxs]
            if flare_labs is not None:
                flare_labs = [flare_labs[ii] for ii in idxs]

        ifig, iax = ctc_grp_intf.plot_freqs_as_flareplot(ctc_cutoff_Ang,
                                                         consensus_maps=consensus_maps,
                                                         SS=refgeom,
                                                         fragment_names=flare_labs,
                                                         fragments=flare_frags,
                                                         sparse=_np.hstack(flare_frags),
                                                         #panelsize=_np.max(ifig.get_size_inches()),
                                                         # TODO deal with the color madness
                                                         colors=_mdcfu.col_list_from_input_and_fragments(True, flare_frags),
                                                         )
        ifig.tight_layout()
        if savefiles:
            ifig.savefig(fname_flare,bbox_inches="tight")
            print(fname_flare)

    if plot_timedep or separate_N_ctcs:
        myfig = ctc_grp_intf.plot_timedep_ctcs(panelheight,
                                               color_scheme=_my_color_schemes(curve_color),
                                               ctc_cutoff_Ang=ctc_cutoff_Ang,
                                               dt=_mdcu.str_and_dict.tunit2tunit["ps"][t_unit],
                                               gray_background=gray_background,
                                               n_smooth_hw=n_smooth_hw,
                                               plot_N_ctcs=True,
                                               pop_N_ctcs=separate_N_ctcs,
                                               shorten_AAs=short_AA_names,
                                               skip_timedep=not plot_timedep,
                                               t_unit=t_unit)
        if savefiles:
            _manage_timedep_ploting_and_saving_options(ctc_grp_intf, myfig,
                                                       ctc_cutoff_Ang,
                                                       output_desc,
                                                       graphic_ext,
                                                       output_dir=output_dir,
                                                       graphic_dpi=graphic_dpi,
                                                       plot_timedep=plot_timedep,
                                                       table_ext=table_ext,
                                                       t_unit=t_unit,
                                                       separate_N_ctcs=separate_N_ctcs
                                                       )
        if len(myfig)==0:
            print("No figures of time-traces were produced because only 1 frame was provided")

    return ctc_grp_intf


def sites(site_files,
          topology,
          trajectories=None,
          ctc_cutoff_Ang=3.5,
          stride=1,
          scheme="closest-heavy",
          chunksize_in_frames=10000,
          n_smooth_hw=0,
          pbc=True,
          BW_uniprot="None",
          CGN_PDB="None",
          fragments=['lig_resSeq+'],
          default_fragment_index=None,
          fragment_names="",
          output_dir='.',
          graphic_ext=".pdf",
          t_unit='ns',
          curve_color="auto",
          gray_background=False,
          graphic_dpi=150,
          short_AA_names=False,
          save_nomenclature_files=False,
          ylim_Ang=10,
          n_jobs=1,
          accept_guess=False,
          table_ext=None,
          output_desc="sites",
          plot_atomtypes=False,
          distro=False,
          savefiles=True,
          ):

    ylim_Ang = _np.float(ylim_Ang)
    _offer_to_create_dir(output_dir)

    # Prepare naming
    output_desc = output_desc.rstrip(".")
    if table_ext is not None:
        table_ext = table_ext.strip(".")
    graphic_ext = graphic_ext.strip(".")
    # Inform about trajectories
    if trajectories is None:
        trajectories = topology
    xtcs = _mdcu.str_and_dict.get_sorted_trajectories(trajectories)
    print("Will compute the sites\n %s\nin the trajectories:\n%s\n with a stride of %u frames.\n" % (
        "\n ".join([_mdcsites.site2str(ss) for ss in site_files]),
        _mdcu.str_and_dict.inform_about_trajectories(xtcs),
          stride))

    # Inform about fragments
    refgeom = _load_any_geom(topology)

    # TODO decide if/to expose _fragments_strings_to_fragments or refactor it elsewhere
    fragments_as_residue_idxs, user_wants_consenus = _mdcfrg.fragments._fragments_strings_to_fragments(fragments, refgeom.top, verbose=True)
    fragment_names = _parse_fragment_naming_options(fragment_names, fragments_as_residue_idxs)
    fragment_defs, consensus_maps, __ = \
        _parse_consensus_options_and_return_fragment_defs({"BW": BW_uniprot,
                                                           "CGN": CGN_PDB},
                                                          refgeom.top,
                                                          fragments_as_residue_idxs,
                                                          accept_guess=accept_guess,
                                                          save_nomenclature_files=save_nomenclature_files)
    sites = [_mdcsites.load(ff) for ff in site_files]
    ctc_idxs_small, AAresSeq2residxs = _mdcsites.sites_to_res_pairs(sites, refgeom.top,
                                                                    fragments=fragments_as_residue_idxs,
                                                                    default_fragment_idx=default_fragment_index,
                                                                    fragment_names=fragment_names)

    print('%10s  %10s  %10s  %10s %10s %10s' % tuple(("residue  residx fragment  resSeq BW  CGN".split())))
    for idx in AAresSeq2residxs.values():
        print('%10s  %10u  %10u %10u %10s %10s' % (refgeom.top.residue(idx), idx, _mdcu.lists.in_what_fragment(idx,
                                                                                                   fragments_as_residue_idxs),
                                                   idx,
                                                   consensus_maps[0][idx], consensus_maps[1][idx]))

    ctcs, time_array, at_pair_trajs = _mdcctcs.trajs2ctcs(xtcs, refgeom.top, ctc_idxs_small, stride=stride,
                                       chunksize=chunksize_in_frames,
                                       return_times_and_atoms=True, consolidate=False, periodic=pbc,
                                       scheme=scheme,
                                       n_jobs=n_jobs)

    # Abstract each site to a group of contacts and fragments
    site_as_gc = {}
    ctc_pairs_iterators = iter(ctc_idxs_small)
    ctc_value_idx = iter(_np.arange(len(ctc_idxs_small)))  # there has to be a better way
    for isite in sites:
        key = isite["name"]
        site_as_gc[key] = []
        for __ in range(isite["n_bonds"]):
            pair = next(ctc_pairs_iterators)
            idx = next(ctc_value_idx)
            consensus_labels = [_mdcnomenc.choose_between_consensus_dicts(idx, consensus_maps) for idx in pair]
            fragment_idxs = [_mdcu.lists.in_what_fragment(idx, fragments_as_residue_idxs) for idx in pair]
            site_as_gc[key].append(_mdcctcs.ContactPair(pair,
                                               [itraj[:, idx] for itraj in ctcs],
                                               time_array,
                                               top=refgeom.top,
                                               consensus_labels=consensus_labels,
                                               trajs=xtcs,
                                               fragment_idxs=fragment_idxs,
                                               fragment_names=[fragment_names[idx] for idx in fragment_idxs],
                                               atom_pair_trajs=[itraj[:, [idx * 2, idx * 2 + 1]] for itraj in
                                                                at_pair_trajs]

                                               #colors=[fragcolors[idx] for idx in idxs]
                                               ))
        site_as_gc[key] = _mdcctcs.ContactGroup(site_as_gc[key])

    panelheight = 3
    n_cols = _np.min((4, len(sites)))
    n_rows = _np.ceil(len(sites) / n_cols).astype(int)
    panelsize = 4
    panelsize2font = 3.5
    histofig, histoax = _plt.subplots(n_rows, n_cols, sharex=True, sharey=True,
                                      figsize=(n_cols * panelsize * 2, n_rows * panelsize), squeeze=False)

    # One loop for the histograms
    _rcParams["font.size"] = panelsize * panelsize2font
    for jax, (site_name, isite_nh) in zip(histoax.flatten(),
                                       site_as_gc.items()):
        if distro:
            isite_nh.plot_distance_distributions(nbins=20,
                                                 jax=jax,
                                                 label_fontsize_factor=panelsize2font / panelsize,
                                                 shorten_AAs=short_AA_names,
                                                 ctc_cutoff_Ang=ctc_cutoff_Ang,
                                                 )
        else:
            isite_nh.plot_freqs_as_bars(ctc_cutoff_Ang, site_name,
                                        jax=jax,
                                        xlim=_np.max([ss["n_bonds"] for ss in sites]),
                                        label_fontsize_factor=panelsize2font / panelsize,
                                        shorten_AAs=short_AA_names,
                                        plot_atomtypes=plot_atomtypes,
                                        )
        print()
        print(isite_nh.frequency_dataframe(ctc_cutoff_Ang).round({"freq": 2, "sum": 2}))
        print()

    if scheme!="closest-heavy":
        scheme_desc='%s.'%scheme
    else:
        scheme_desc=''
    histofig.tight_layout(h_pad=2, w_pad=0, pad=0)
    fname = "%s.overall@%2.1f_Ang.%s" % (output_desc, ctc_cutoff_Ang, graphic_ext.strip("."))
    fname = _path.join(output_dir, fname)
    if savefiles:
        histofig.savefig(fname, dpi=graphic_dpi)
        print("The following files have been created")
        print(fname)
    _plt.close(histofig)
    for site_name, isite_nh in site_as_gc.items():
        fname_no_time = '%s.%s@%2.1f_Ang.%s' % (output_desc,
                                        site_name.strip().replace(" ","_"),
                                        ctc_cutoff_Ang,
                                        table_ext)
        fname_no_time = _path.join(output_dir, fname_no_time)


        fname = '%s.%s.time_trace@%2.1f_Ang.%s' % (output_desc,
                                        site_name.strip().replace(" ","_"),
                                        ctc_cutoff_Ang,
                                        graphic_ext)
        fname = _path.join(output_dir,fname)
        myfig = isite_nh.plot_timedep_ctcs(panelheight,
                                           color_scheme=_my_color_schemes(curve_color),
                                           ctc_cutoff_Ang=ctc_cutoff_Ang,
                                           n_smooth_hw=n_smooth_hw,
                                           dt=_mdcu.str_and_dict.tunit2tunit["ps"][t_unit],
                                           t_unit=t_unit,
                                           gray_background=gray_background,
                                           shorten_AAs=short_AA_names,
                                           plot_N_ctcs=True,
                                           ylim_Ang=ylim_Ang,
                                           )[0]
        # One title for all axes on top
        myfig.axes[0].set_title("site: %s" % (isite["name"]))
        if savefiles:
            _plt.savefig(fname, bbox_inches="tight", dpi=graphic_dpi)
            print(fname)

            if table_ext is not None and savefiles:
                if table_ext == 'xlsx':
                    isite_nh.frequency_spreadsheet(ctc_cutoff_Ang, fname_no_time,
                                                write_interface=False,
                                                by_atomtypes=True,
                                                # AA_format="long",
                                                split_label="join"
                                                )
                else:
                    with open(fname_no_time, 'w') as f:
                        f.write(isite_nh.frequency_str_ASCII_file(ctc_cutoff_Ang))
                print(fname_no_time)
        _plt.close(myfig)

    return site_as_gc

def compare(file_dict, graphic_ext=".pdf", output_desc="freq_comparison",**kwargs):
    myfig, freqs, plotted_freqs = _mdcplots.compare_groups_of_contacts(file_dict, **kwargs)
    myfig.tight_layout()

    output_desc=output_desc.strip(".").replace(" ","_")
    fname = "%s.%s" % (output_desc, graphic_ext.strip("."))
    print("Created files")
    myfig.savefig(fname)
    print(fname)
    fname_excel = "%s.xlsx" % output_desc
    writer = _ExcelWriter(fname_excel, engine='xlsxwriter')
    workbook = writer.book
    sheet1_name = "plotted frequencies"
    writer.sheets[sheet1_name] = workbook.add_worksheet(sheet1_name)
    offset = 0
    header = 'pairs by contact frequency'
    if "anchor" in kwargs.keys():
        header+= "(anchor was %s)"%kwargs["anchor"]
    writer.sheets[sheet1_name].write_string(0, offset,header
                                            )
    offset += 1
    _DF.from_dict(plotted_freqs).round({"freq": 2, "sum": 2}).to_excel(writer,
                                                                       sheet_name=sheet1_name,
                                                                       startrow=offset,
                                                                       startcol=0,
                                                                       )
    # offset = 0
    sheet2_name = "all frequencies"
    writer.sheets[sheet2_name] = workbook.add_worksheet(sheet2_name)
    writer.sheets[sheet2_name].write_string(offset, 0, 'pairs by contact frequency')
    _DF.from_dict(freqs).round({"freq": 2, "sum": 2}).to_excel(writer,
                                                               sheet_name=sheet2_name,
                                                               startrow=offset,
                                                               startcol=0,
                                                               )
    writer.save()
    print(fname_excel)
    #_plt.show()

    return myfig, freqs, plotted_freqs
